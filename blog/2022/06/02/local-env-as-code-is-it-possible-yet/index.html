<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta name=viewport content="width=device-width,initial-scale=1"><title>Local Env as Code: Is it possible yet?</title><meta name=author content="cncs"><meta name=keywords content="cloudnative,cncs,Cloud Native Computing Sphere,cncncs,cncf"><meta name=description content="Cloud Native Computing Sphere. Sustaining and integrating cloud native open source technologies."><link href='//fonts.loli.net/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel=stylesheet type=text/css><link rel=stylesheet href=//use.fontawesome.com/releases/v5.11.2/css/all.css><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link href=/css/animate.css rel=stylesheet><link href=/css/style.default.css rel=stylesheet id=theme-stylesheet><link href=/css/custom.css?1654616047 rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel="shortcut icon" href=/img/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link href=/css/owl.carousel.css rel=stylesheet><link href=/css/owl.theme.css rel=stylesheet><link rel=alternate href=https://cncs.tech/index.xml type=application/rss+xml title="Cloud Native Computing Sphere"><meta property="og:locale" content="en_us"><meta property="og:site_name" content="Cloud Native Computing Sphere"><meta property="og:title" content="Local Env as Code: Is it possible yet?"><meta property="og:type" content="article"><meta property="og:url" content="https://cncs.tech/blog/2022/06/02/local-env-as-code-is-it-possible-yet/"><meta property="og:description" content="Cloud Native Computing Sphere. Sustaining and integrating cloud native open source technologies."><meta property="og:image" content="https://cncs.tech/img/cncf-ref/local-env-as-code.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="776"><meta property="og:image:height" content="408"><meta property="og:updated_time" content="2022-06-02T21:49:20+0200"><meta property="article:section" content="cncf-translation"><meta property="article:tag" content="cncf"><meta property="article:published_time" content="2022-06-02T21:49:20+0200"><meta property="article:modified_time" content="2022-06-02T21:49:20+0200"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Local Env as Code: Is it possible yet?"><meta name=twitter:image content="https://cncs.tech/img/cncf-ref/local-env-as-code.png"><meta name=twitter:description content="Cloud Native Computing Sphere. Sustaining and integrating cloud native open source technologies."></head><body><div id=all><header class=navbar-affixed-top data-spy=affix data-offset-top=62><div class="navbar navbar-default yamm" role=navigation id=navbar><div class=container><div class=navbar-header><a class="navbar-brand home" href=/><img src=/img/logo.svg alt="Local Env as Code: Is it possible yet? logo" class="hidden-xs hidden-sm">
<img src=/img/logo-small.svg alt="Local Env as Code: Is it possible yet? logo" class="visible-xs visible-sm">
<span class=sr-only>Local Env as Code: Is it possible yet? - go to homepage</span></a><div class=navbar-buttons><button type=button class="navbar-toggle btn-template-main" data-toggle=collapse data-target=#navigation>
<span class=sr-only>Toggle Navigation</span>
<i class="fas fa-align-justify"></i></button></div></div><div class="navbar-collapse collapse" id=navigation><ul class="nav navbar-nav navbar-right"><li class=dropdown><a href=/about/>About</a></li><li class=dropdown><a href=/community/>Community</a></li><li class="dropdown active"><a href=/blog/>Blog</a></li><li class=dropdown><a href=/faq/>FAQ</a></li><li class=dropdown><a href=/contact/>Contact</a></li></ul></div><div class="collapse clearfix" id=search><form class=navbar-form role=search><div class=input-group><input type=text class=form-control placeholder=Search>
<span class=input-group-btn><button type=submit class="btn btn-template-main"><i class="fas fa-search"></i></button></span></div></form></div></div></div></header><div id=heading-breadcrumbs><div class=container><div class=row><div class=col-md-12><h1>Local Env as Code: Is it possible yet?</h1></div></div></div></div><div id=content><div class=container><div class=row><div class=col-md-9 id=blog-post><p class="text-muted text-uppercase mb-small text-right">By <a href=/authors/jan-van-bruggen>Jan Van Bruggen</a>
June 2, 2022</p><div id=post-content><blockquote><p>Guest post by Jan Van Bruggen, Developer Relations Lead at itopia</p></blockquote><p>In the past decade, we’ve seen the rise, standardization and meme-ification of “as code”: Infrastructure as Code, Monitoring as Code, Policy as Code and soon perhaps <a href=https://thenewstack.io/the-coming-era-of-data-as-code/>Data as Code</a>. Essentially, “Stuff as Code” is the practice of statelessly automating the management of “stuff” via version-controlled, declarative configuration files. Therefore, it’s worth asking if the same DevOps practice can be applied effectively to a set of unstable resources even more near and dear to developers than their backends – their local coding environments.</p><p>The common problem of developer environment configuration drift is a minor inconvenience when revisiting old projects or following outdated tutorials, but it might cost a professional developer days of progress every month to restore/update their environment(s), especially on a technologically-diversified team. Unfortunately, Terraform can’t save us from <a href=https://xkcd.com/1987/>local dependency hell</a>, and Kubernetes can’t help Windows and macOS laptops collaborate on a codebase… <a href=https://xkcd.com/934/>right</a>? Is it possible to solve these local environment problems with declarative configuration files, version control and a practice of stateless automation?</p><p>Let’s consider everything “local” that a person depends upon when writing code:</p><ul><li>integrated development environments (IDEs)</li><li>personal settings</li><li>project-specific libraries</li><li>system wide packages</li><li>operating system (OS)</li><li>computer hardware</li><li>internet connection</li><li>electricity</li><li>cup of water next to their keyboard</li></ul><p>One reason that local environments are resistant to configuration is that each of those layers depends on the layers below it, so any careful effort to statelessly automate an upper layer will be undermined by stateful chaos below. For example, a Python project’s dependencies may be defined in a declarative requirements.txt file, but the result of each execution will vary based on what environment variables are set and OS packages are installed. VS Code supporting containerized environments was a major step forward, but it depends upon manual maintenance of a Docker installation (as well as a compatible OS and <a href=https://thenewstack.io/the-time-to-decide-on-docker-desktop-has-arrived>subscription</a> to run Docker in the first place).</p><p>So, is it impossible to statelessly automate a complete local environment? No.</p><h2 id=configure-an-environment>Configure an environment</h2><p>We’ve recently seen significant progress in the stateless configurability of those chaotic middle layers, and developer workflows are evolving in response. Let’s evaluate the current configurability of each of the software-defined layers of local environments:</p><h2 id=personal-settings>Personal settings</h2><p>Underneath an IDE, the highest-level layer of configuration is <strong>personalization</strong>. This consists of configuration files that override default settings in apps and tools, such as for…</p><ul><li>IDEs: settings.json, options/*.xml, .vimrc, .editorconfig, etc.</li><li>Terminals: .bashrc, .zshrc, .tmux.conf, etc.</li><li>Other: .gitconfig, psqlrc, etc.</li></ul><blockquote><p>Fun fact: The reason that many of these file names start with a period (and are therefore known as “dotfiles”) is <a href=https://linux-audit.com/linux-history-how-dot-files-became-hidden-files/>the accidental invention of “hidden files” in 1997</a>.</p></blockquote><p>IDEs depend on personalization for shortcuts, keybindings, accessibility, layout and aesthetics. These files should always be different from one developer to another, as everyone has their own unique needs and habits. So how can we automatically manage personalization across devices and environments without treating developers homogeneously?</p><p>The most popular answer is to use a “dotfile manager” like <a href=https://www.chezmoi.io/what-does-chezmoi-do/>chezmoi</a>, <a href=https://github.com/anishathalye/dotbot>Dotbot</a>, <a href=https://yadm.io/>yadm</a>, or others. Dotfile managers <a href=https://www.chezmoi.io/comparison-table/>each have different features</a>, but they all automate the process of updating personalization files to achieve a desired, version-controlled state. Some even use declarative configuration files!</p><p>It seems that “personalization as code” is a solved problem. Although dotfile managers aren’t quite mainstream yet, using one is highly recommended for professional developers that work on multiple devices or accounts, for it will save a lot of time in setting up, context switching between and debugging those environments.</p><h2 id=project-libraries>Project libraries</h2><p>From Java to Rust, almost every software project imports third-party libraries, and this layer is already managed “as code”. A declarative configuration file for library dependencies is usually included with project source code in version control:</p><ul><li><a href=https://maven.apache.org/guides/introduction/introduction-to-the-pom.html>pom.xml</a> for Java with Maven</li><li><a href=https://pip.pypa.io/en/stable/user_guide/#requirements-files>requirements.txt</a> for Python</li><li><a href=https://docs.npmjs.com/cli/v7/configuring-npm/package-json>package.json</a> for Node.js</li><li><a href=https://doc.rust-lang.org/cargo/guide/dependencies.html>Cargo.toml</a> for Rust</li></ul><p>The list goes on, with an industry-standard protocol for almost every programming language.</p><blockquote><p>Fun fact: For years, the major exceptions to this trend were C and C++, due to their unique integration with system packages (see next section) and (presumably) the inertia of legacy workflows. However, today both <a href=https://conan.io/>Conan</a> and <a href=https://vcpkg.io/>vcpkg</a> seem to be popular and growing.</p></blockquote><p>IDEs often depend on these libraries to format, analyze and execute source code, so it’s a boon to developer experience that these configuration files are distributed within source code. In fact, “library dependencies as code” has already been solved so completely for so long that…</p><ul><li>almost every project starts statelessly managing its library dependencies on day one.</li><li>almost every programming language is expected to have a library management protocol.</li><li>it’s an unused phrase, since it just seems like common sense.</li><li>it’s taken for granted by most developers until someone calls attention to its omnipresence when talking about other-stuff-as-code.</li></ul><h2 id=system-packages>System packages</h2><p>Unlike project-specific libraries, system wide (and per-user) packages are used across multiple/all of a developer’s projects and are tailored to each OS. These include:</p><ul><li>compilers and interpreters like gcc and python</li><li>clients and servers, like curl and apache</li><li>terminal shells and GUIs, like xterm and gnome</li></ul><p>In addition to being packages themselves, IDEs depend on other packages to render views, connect to services, and analyze/execute code. Each project depends on a unique set of packages, so each developer installs a unique collection of these packages on their OS. However, usually only one version of a package can be installed at a time, and sometimes different packages are incompatible or compete with each other. This leads to frustrating dependency mismatches between (and conflicts within) environments, so is there a way to automatically manage a project’s package dependencies across devices and environments without breaking another project’s package dependencies?</p><p>For the past few decades, a stateful solution has been popular: using a package manager like <a href=https://en.wikipedia.org/wiki/APT_(software)>APT</a>, <a href=https://wiki.archlinux.org/title/pacman>pacman</a>, <a href=https://brew.sh/>Homebrew</a> or <a href=https://chocolatey.org/>Chocolatey</a> to install specific package versions one at a time. These tools enable powerful setup scripts, which are more reliable and maintainable when paired with the sterility and ephemerality of containerization (more on that in the next section). Unfortunately, without containerization, a stateful configuration is inherently less scalable than a stateless configuration, which can know at any point in the future if it has become invalid/conflicted and then efficiently repair itself; just ask anyone who chooses Terraform’s approach to Infrastructure as Code for this reason!</p><p>That’s why it’s so exciting to see <a href=https://github.com/NixOS/nix>Nix</a> slowly <a href=https://shopify.engineering/shipit-presents-how-shopify-uses-nix>becoming</a> <a href=https://blog.replit.com/nix>more</a> <a href=https://medium.com/att-israel/how-nix-shell-saved-our-teams-sanity-a22fe6668d0e>popular</a>, because Nix is a stateless solution to the same problem. By installing one or more immutable versions of each individual package and explicitly translating package dependencies (both direct and indirect) into a DAG, Nix can future-proof environments against most forms of bit rot and greatly simplify collaboration between developers who use different OSes. Any developer experiencing OS-level dependency hell should definitely install Nix and see if nix-shell brightens their whole week.</p><h2 id=operating-systems>Operating systems</h2><p>At the bottom of every developer’s software stack is their <strong>operating system</strong> (OS), which includes various subsystems:</p><ul><li>application platform</li><li>file management</li><li>drivers</li><li>resource (processors, memory, etc.) management</li></ul><p>It’s impossible to statelessly configure the OS that’s installed on most developers’ computers, so the most popular approach to managing this layer is to instead use containerized guest OSes to host developer environments. For our purposes, “guest OSes” means each environment is isolated from each other, and “containerized” means each environment’s specification can be version-controlled.</p><blockquote><p>Fun fact: Actually, a couple of stateless OSes do exist, but they’re just not (yet) popular. <a href=https://nixos.org/guides/how-nix-works.html#nixos>NixOS</a> is a stateless OS managed entirely by the Nix package manager, and <a href=https://guix.gnu.org/en/about/>Guix System</a> is a libre copycat of NixOS. Adventurous developers might fall in love with NixOS, but it might not (yet) support all of their development tools out of the box, largely due to its radically-different design.</p></blockquote><p><a href=https://docs.docker.com/get-started/overview/>Docker</a> has remained the best platform for specifying, building, and running containers, ever since it originated most of the concepts and jargon about containers. Although it implements a stateful system for specifying build steps, a built container image is an immutable artifact that can be referenced in declarative configuration files.</p><h2 id=recommended-approach>Recommended approach</h2><p>While it’s ideal to have stateless automation for every layer, you can incrementally upgrade your environment by introducing new automation tools individually. Nix alone is a powerful addition to projects, and chezmoi alone is a friendly assistant for developers.</p><p>On the other hand, if you want to jump straight to a fully-automated environment, the best way to set up and maintain a fully-automated local environment is this:</p><ul><li>when building an environment<ul><li>statefully configure a guest OS with Docker</li><li>statefully configure some system packages with your OS’s package manager</li></ul></li><li>when running an environment<ul><li>statelessly configure a container with a built container image</li><li>statelessly configure most system packages with Nix</li><li>statelessly configure project libraries with your language’s tool of choice</li><li>statelessly configure personal settings with chezmoi</li></ul></li></ul><p>Depending on your use case, you may want to move some or all of those stateless configuration steps into the build process, to cache their results in container image layers.</p><h2 id=run-an-ide>Run an IDE</h2><p>With all of the above tools at our disposal, we have a variety of ways to reliably and reproducibly configure a local environment. This environment can be a minimal and performant daily driver, as well as isolated from personal files, messaging apps, other environments, and Docker itself. However, it’s not immediately obvious how to interact with an IDE that’s running inside a container, which is a necessary next step (unless you chose NixOS, which doesn’t require containers).</p><p>A locally-installed IDE can be used locally, since the IDE acts as its own client, but most containerized IDEs require using an IDE client that is separate from the IDE server, in order to communicate between the OSes. Here are some notable IDE clients, including both web-based (“online IDE”) and native (“hybrid IDE”):</p><h2 id=vs-code>VS Code</h2><p>VS Code is a popular IDE, and it was the first to provide both hybrid and online solutions.</p><p><a href=https://code.visualstudio.com/docs/remote/remote-overview>Remote Development</a> is a set of first-party VS Code extensions that, among other things allow an existing VS Code installation to be used as a hybrid IDE, connected to a VS Code server running somewhere. This is an easy solution to set up, but it does require the user to either configure a VS Code server in their container or use <a href=https://code.visualstudio.com/docs/remote/containers>the containers extension</a> to host the whole developer environment. This is a tool for solo developers who want to use their local VS Code IDE as their IDE client.</p><p>Alternatively, <a href=https://github.com/coder/code-server>code-server</a> is a third-party VS Code web server that renders the VS Code client in a web app as an online IDE, connected to a VS Code server. This is a flexible online solution that requires advanced website hosting skills, but it can’t support extensions from Microsoft’s marketplace. This is a tool for solo developers who want to use VS Code non-locally.</p><h2 id=jetbrains-ides>JetBrains IDEs</h2><p><a href=https://lp.jetbrains.com/projector/>Projector</a> is a first-party containerization solution for the JetBrains suite of IDEs: PyCharm, IntelliJ IDEA, PhpStorm, etc. This allows you to run any JetBrains IDE as an online IDE, but the UX is inconsistent with their native apps because Projector implements an HTML5 connector for the IDE’s Swing-based GUIs.</p><h2 id=other-ides>Other IDEs</h2><p><a href=https://github.com/selkies-project/selkies-gstreamer>selkies-gstreamer</a> is a DIY containerization solution for running any Linux-compatible IDE/GUI in a container, with a browser-based interface. We’ll discuss the broader <a href=https://selkies.io/>Selkies</a> platform more in a later section, since it’s a very unique solution, but this standalone component is a powerful tool for solo developers who want to run a specific IDE/GUI that doesn’t have its own containerization tool or web frontend.</p><h2 id=scaling-problems>Scaling problems</h2><p>These solutions all require a little Docker tinkering, but they’re great for solo developers. However, deploying and scaling them to serve a medium-sized development team require specialized skills in container orchestration and networking. It’s a nontrivial technical challenge to performantly configure and scalably maintain a Kubernetes cluster for per-user app streaming sessions, and distributed/remote teams may require multiple clusters on multiple continents, which add extra dimensions of maintenance complexity.</p><h2 id=scale-to-serve-your-team>Scale to serve your team</h2><p>We at <a href=https://itopia.com/>itopia</a> thought that kind of automation challenge sounded like it would be more fun for our remote workstations team than it would be for the average development team, because most teams have higher priorities than maintaining a workstation cluster. itopia has been managing remote enterprise workstations for almost a decade, so we have some insights into how large teams adopt, scale and maintain productivity-focused environments.</p><h2 id=designed-with-large-teams-in-mind>Designed with large teams in mind</h2><p>Large teams have the following preferences, regarding remote workstations:</p><ul><li>Portability: <a href=https://thenewstack.io/are-cloud-based-ides-the-future-of-software-engineering/>Browser-based IDE clients are more convenient than OS-native IDE clients</a>.</li><li>Performance: Web apps should do all heavy computation and networking in the cloud, rather than in the browser, to prevent resource bottlenecks.</li><li>Flexibility: All IDEs should be supported with identical UX to local installations, to minimize transition costs and maximize developer efficiency.</li><li>Security: High-security endpoints are essential for protecting intellectual property.</li><li>Maintenance: A fully-managed service is usually more pragmatic for enterprises than a self-hosted one, due to the nuanced upkeep required for self-hosting.</li><li>Transparency: Open source tech is more flexible, secure, and auditable than closed source tech, which matters to CTOs and sysadmins alike.</li></ul><p>We were surprised to discover that no solution existed to satisfy all of the above preferences, which meant that teams had to compromise in some way. Both browser-rendered and native IDE clients, which together covered most solutions, require streaming source code to all developer devices, with little protection against IP exfiltration. Opinionated services like <a href=https://github.com/features/codespaces>GitHub Codespaces</a> are inflexible in their support for only one IDE and version control system. Some solutions offer self-hosting as a security and flexibility upgrade, but that adds maintenance labor.</p><p><a href=https://itopiaspaces.com/>itopia Spaces</a> checks all the right boxes for teams and enterprises; here’s a free <a href=https://test-drive.itopia.space/>test drive</a> to prove it. See <a href=https://github.com/itopia-inc/spaces-images>our open source catalog of itopia-managed images</a> for both ideas of what’s possible and starting points for your uniquely-customized images.</p><p>The core technology is public, so also check out <a href=https://selkies.io/>Selkies</a>, the <a href=https://github.com/selkies-project>open source</a> cloud-native streaming platform we’ve created <a href=https://github.com/GoogleCloudPlatform/selkies>in partnership with Google</a>. If you like what you see today, <a href=https://discord.gg/byveDRm3Wv>join our community</a> and let us know what you want to see tomorrow! We love seeing people building on Selkies, and together we hope to cultivate a high-quality new standard for remote app streaming.</p><p>It’s satisfying to see how much recent progress has been made in improving developer environments, and it’s exciting to think what the process of coding might look like in a few years. At the very least, however, developers will be able to reliably configure their environments to suit their needs without spending a week manually typing commands and editing files any time a project – or the angle of the cup of water next to their keyboard – changes.</p><p><a href=https://www.cncf.io/blog/2022/06/02/local-env-as-code-is-it-possible-yet%ef%bf%bc/>https://www.cncf.io/blog/2022/06/02/local-env-as-code-is-it-possible-yet%ef%bf%bc/</a></p></div><script src=https://giscus.app/client.js data-repo=cncncs/community data-repo-id=R_kgDOHZl1Dw data-category=Announcements data-category-id=DIC_kwDOHZl1D84CPTfa data-mapping=title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class=col-md-3><div class="panel panel-default sidebar-menu"><div class=panel-heading><h3 class=panel-title>Search</h3></div><div class=panel-body><form action=//google.com/search method=get accept-charset=utf-8 role=search><div class=input-group><input type=search name=q class=form-control placeholder=Search>
<input type=hidden name=sitesearch value=https://cncs.tech/>
<span class=input-group-btn><button type=submit class="btn btn-template-main"><i class="fas fa-search"></i></button></span></div></form></div></div><div class="panel panel-default sidebar-menu"><div class=panel-heading><h3 class=panel-title>Categories</h3></div><div class=panel-body><ul class="nav nav-pills nav-stacked"><li><a href=/categories/cncf-translation>CNCF-TRANSLATION (3)</a></li></ul></div></div><div class="panel sidebar-menu"><div class=panel-heading><h3 class=panel-title>Tags</h3></div><div class=panel-body><ul class=tag-cloud><li><a href=/tags/cncf><i class="fas fa-tags"></i> cncf</a></li></ul></div></div></div></div></div></div><footer id=footer><div class=container><div class="col-md-4 col-sm-6"><h4>ContactUs</h4><p><img src=//cncs.tech/img/contact-qr.png></div><div class="col-md-4 col-sm-6"></div><div class="col-md-4 col-sm-6"><h4></h4><div class=social><a href=https://github.com/cncncs target=_blank style=opacity:1><i class="fab fa-2x fa-github"></i></a>
<a href=https://www.facebook.com/groups/cncs.tech target=_blank style=opacity:1><i class="fab fa-2x fa-facebook"></i></a></div><br><p></div></div><div id=copyright><div class=container><div class=col-md-12><p class=pull-left><hr>Copyright © 2022 Cloud Native Computing Sphere(CNCS)®. All rights reserved.</p></div><div style=float:right><a href=javascript:void(0); title><select id=language-select-desktop onchange="location=this.value"><option value=/blog/2022/06/02/local-env-as-code-is-it-possible-yet/ selected>
English</option><option value=/zh/blog/2022/06/02/local-env-as-code-is-it-possible-yet/>
中文</option></select></a></div></div></div></footer></div><script src=//code.jquery.com/jquery-3.1.1.min.js integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin=anonymous></script>
<script src=//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js></script>
<script src=/js/front.js></script>
<script src=/js/owl.carousel.min.js></script></body></html>